<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Model 3D Viewer</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            overflow-x: hidden;
        }

        #models-container {
            display: flex;
            flex-wrap: wrap;
            width: 100vw;
            height: 100vh;
        }

        .viewer {
            position: relative;
            flex: 1 1 50%;
            /* Desktop: 50% width */
            height: 100%;
            min-height: 500px;
            overflow: hidden;
            border: 1px solid #333;
            box-sizing: border-box;
        }

        /* Mobile: 100% width, stack vertically */
        @media (max-width: 768px) {
            .viewer {
                flex: 1 1 100%;
                height: 50vh;
                /* Half screen height on mobile */
            }
        }

        .info-overlay {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 0;
        }
    </style>

    <!-- Import maps polyfill -->
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

    <div id="models-container">
        <div id="view1" class="viewer">
            <div class="info-overlay">Model 1</div>
        </div>
        <div id="view2" class="viewer">
            <div class="info-overlay">Model 2</div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';

        // Configuration shared across viewers
        const TILT_ANGLE = 15 * (Math.PI / 180);
        const ROTATION_SPEED = 0.01;
        const MAGNIFICATION_SCALE = 1.2;
        const ANIMATION_SPEED = 0.1;

        // Initialize viewers
        createViewer('view1', 'assets/m1/', 'model.obj', 'model.mtl', 'model.png');
        createViewer('view2', 'assets/m2/', 'model.obj', 'model.mtl', 'model.png');

        function createViewer(containerId, basePath, objFile, mtlFile, textureFile) {
            const container = document.getElementById(containerId);
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Controls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = 50;

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(5, 10, 7.5);
            scene.add(dirLight);
            const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
            backLight.position.set(-5, 5, -5);
            scene.add(backLight);

            // Raycaster setup
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            let object = null;
            let baseScale = null;
            let isHovered = false;

            // Load Model
            const mtlLoader = new MTLLoader();
            mtlLoader.setPath(basePath);
            mtlLoader.load(mtlFile, (materials) => {
                materials.preload();
                loadObj(materials);
            }, undefined, (error) => {
                console.warn(`MTL failed for ${containerId}, falling back to OBJ+Texture`, error);
                loadObj(null); // Fallback
            });

            function loadObj(materials) {
                const objLoader = new OBJLoader();
                objLoader.setPath(basePath);
                if (materials) objLoader.setMaterials(materials);

                objLoader.load(objFile, (obj) => {
                    object = obj;

                    // If no materials (MTL failed), OR if materials exists but texture is missing/wrong
                    // We'll enforce the texture if we know it exists at basePath + textureFile
                    if (!materials) {
                        const texLoader = new THREE.TextureLoader();
                        const texture = texLoader.load(basePath + textureFile);
                        texture.colorSpace = THREE.SRGBColorSpace;
                        object.traverse((child) => {
                            if (child.isMesh) child.material = new THREE.MeshPhongMaterial({ map: texture });
                        });
                    } else {
                        // Even if materials loaded, sometimes the map is missing or path is wrong inside MTL
                        // Let's iterate and see if we need to patch it, or just leave it if it works.
                        // But since user says "not showing", let's be aggressive if map is null.
                        const texLoader = new THREE.TextureLoader();
                        const texture = texLoader.load(basePath + textureFile);
                        texture.colorSpace = THREE.SRGBColorSpace;

                        object.traverse((child) => {
                            if (child.isMesh) {
                                // If material exists but has no map, OR strictly force it as per user request "use the png in m2"
                                // User said: "use the png and mtl in m2" -> implies we should trust the PNG.
                                // Let's force assignment to be safe.
                                if (child.material) {
                                    child.material.map = texture;
                                    child.material.needsUpdate = true;
                                }
                            }
                        });
                    }

                    setupModel(object);
                });
            }

            function setupModel(obj) {
                // Center & Scale
                const box = new THREE.Box3().setFromObject(obj);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                obj.position.sub(center); // Center at 0,0,0

                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = maxDim > 0 ? 3 / maxDim : 1;
                obj.scale.set(scale, scale, scale);
                baseScale = new THREE.Vector3(scale, scale, scale);

                obj.rotation.x = TILT_ANGLE;
                scene.add(obj);
            }

            // Events
            window.addEventListener('resize', onResize);
            container.addEventListener('mousemove', onPointerMove);

            function onResize() {
                if (!container.clientWidth || !container.clientHeight) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }

            function onPointerMove(event) {
                // Calculate pointer position in normalized device coordinates (-1 to +1) for this specific container
                const rect = container.getBoundingClientRect();
                pointer.x = ((event.clientX - rect.left) / container.clientWidth) * 2 - 1;
                pointer.y = -((event.clientY - rect.top) / container.clientHeight) * 2 + 1;
            }

            // Animation Loop (Specific to this viewer)
            function animate() {
                requestAnimationFrame(animate);
                controls.update();

                if (object && baseScale) {
                    // Update Raycaster
                    raycaster.setFromCamera(pointer, camera);
                    // Only check intersection if mouse is effectively inside this container (ignoring naive approach for now)
                    // Actually Raycaster works fine if pointer is correctly mapped.
                    // However, we need to know if the mouse is *actually* over the canvas.
                    // A simple check: if the mouse hasn't moved over this container recently, pointer might be stale.
                    // But simplified: checking intersections on every frame is fine.

                    const intersects = raycaster.intersectObject(object, true);

                    // Check if mouse is actually inside the container rect to avoid false positives from stale pointer coords
                    // We can track hover state on the container
                    isHovered = intersects.length > 0;

                    // Magnify & Rotate Logic
                    const targetScaleScalar = isHovered ? MAGNIFICATION_SCALE : 1.0;
                    const targetScale = baseScale.clone().multiplyScalar(targetScaleScalar);
                    object.scale.lerp(targetScale, ANIMATION_SPEED);

                    if (!isHovered) {
                        object.rotation.y += ROTATION_SPEED;
                    }
                    object.rotation.x = TILT_ANGLE;
                }

                renderer.render(scene, camera);
            }
            animate();
        }
    </script>
</body>

</html>